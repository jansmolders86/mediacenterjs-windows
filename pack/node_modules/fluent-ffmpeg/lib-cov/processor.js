// instrument by jscoverage, do not modifly this file
(function () {
  var BASE;
  if (typeof global === 'object') {
    BASE = global;
  } else if (typeof window === 'object') {
    BASE = window;
  } else {
    throw new Error('[jscoverage] unknow ENV!');
  }
  if (!BASE._$jscoverage) {
    BASE._$jscoverage = {};
    BASE._$jscoverage_cond = {};
    BASE._$jscoverage_done = function (file, line, express) {
      if (arguments.length === 2) {
        BASE._$jscoverage[file][line] ++;
      } else {
        BASE._$jscoverage_cond[file][line] ++;
        return express;
      }
    };
    BASE._$jscoverage_init = function (base, file, lines) {
      var tmp = [];
      for (var i = 0; i < lines.length; i ++) {
        tmp[lines[i]] = 0;
      }
      base[file] = tmp;
    };
  }
})();
_$jscoverage_init(_$jscoverage, "lib/processor.js",[4,5,6,7,8,23,24,29,100,102,103,104,105,109,110,111,115,116,117,118,119,123,124,125,128,129,131,132,135,137,138,141,142,146,148,149,152,155,160,161,162,164,165,166,167,169,174,175,177,178,181,182,183,188,189,191,192,195,196,197,202,214,215,217,218,221,224,227,244,245,246,248,249,250,251,253,256,280,281,283,286,291,292,295,296,297,300,306,308,309,310,313,316,317,318,321,327,328,329,331,334,338,341,343,346,347,348,363,366,369,370,373,374,378,379,383,384,388,390,391,393,394,396,401,402,403,407,408,409,415,416,419,420,421,422,425,426,430,431,432,433,435,436,440,442,445,446,452,453,454,458,459,460,461,465,466,467,472,473,474,476,477,480,481,483,484,487,493,495,496,498,501,504,505,508,509,511,514,516,519,520,527,532,533,535,541,561,562,563,565,566,569,570,572,573,574,575,577,578,581,582,583,584,585,587,593,606,607,608,610,613]);
_$jscoverage_init(_$jscoverage_cond, "lib/processor.js",[102,109,116,118,118,123,123,123,137,137,148,152,152,152,152,152,164,166,174,188,248,250,291,296,308,308,316,338,341,347,373,390,393,402,419,431,440,476,476,480,483,483,483,495,496,508,519,519,532,562,565,565,572,582,584,607]);
_$jscoverage["lib/processor.js"].source = ["/*jshint node:true*/","'use strict';","","var spawn = require('child_process').spawn;","var path = require('path');","var fs = require('fs');","var async = require('async');","var utils = require('./utils');","","","/*"," *! Processor methods"," */","","","/**"," * Run ffprobe asynchronously and store data in command"," *"," * @param {FfmpegCommand} command"," * @private"," */","function runFfprobe(command) {","  command.ffprobe(function(err, data) {","    command._ffprobeData = data;","  });","}","","","module.exports = function(proto) {","  /**","   * Emitted just after ffmpeg has been spawned.","   *","   * @event FfmpegCommand#start","   * @param {String} command ffmpeg command line","   */","","  /**","   * Emitted when ffmpeg reports progress information","   *","   * @event FfmpegCommand#progress","   * @param {Object} progress progress object","   * @param {Number} progress.frames number of frames transcoded","   * @param {Number} progress.currentFps current processing speed in frames per second","   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second","   * @param {Number} progress.targetSize current output file size","   * @param {String} progress.timemark current video timemark","   * @param {Number} [progress.percent] processing progress (may not be available depending on input)","   */","","  /**","   * Emitted when ffmpeg reports input codec data","   *","   * @event FfmpegCommand#codecData","   * @param {Object} codecData codec data object","   * @param {String} codecData.format input format name","   * @param {String} codecData.audio input audio codec name","   * @param {String} codecData.audio_details input audio codec parameters","   * @param {String} codecData.video input video codec name","   * @param {String} codecData.video_details input video codec parameters","   */","","  /**","   * Emitted when an error happens when preparing or running a command","   *","   * @event FfmpegCommand#error","   * @param {Error} error error object","   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream","   * @param {String|null} stderr ffmpeg stderr","   */","","  /**","   * Emitted when a command finishes processing","   *","   * @event FfmpegCommand#end","   * @param {Array|null} [filenames] generated filenames when taking screenshots, null otherwise","   */","","","  /**","   * Spawn an ffmpeg process","   *","   * The 'options' argument may contain the following keys:","   * - 'niceness': specify process niceness, ignored on Windows (default: 0)","   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)","   * - 'captureStderr': capture stderr and pass it to 'endCB' as its 3rd argument (default: false)","   *","   * The 'processCB' callback, if present, is called as soon as the process is created and","   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens","   * before spawning the process.","   *","   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.","   *","   * @method FfmpegCommand#_spawnFfmpeg","   * @param {Array} args ffmpeg command line argument list","   * @param {Object} [options] spawn options (see above)","   * @param {Function} [processCB] callback called with process object when it has been created","   * @param {Function} endCB callback with signature (err, stdout, stderr)","   * @private","   */","  proto._spawnFfmpeg = function(args, options, processCB, endCB) {","    // Enable omitting options","    if (typeof options === 'function') {","      endCB = processCB;","      processCB = options;","      options = {};","    }","","    // Enable omitting processCB","    if (typeof endCB === 'undefined') {","      endCB = processCB;","      processCB = function() {};","    }","","    // Find ffmpeg","    this._getFfmpegPath(function(err, command) {","      if (err) {","        return endCB(err);","      } else if (!command || command.length === 0) {","        return endCB(new Error('Cannot find ffmpeg'));","      }","","      // Apply niceness","      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {","        args.unshift('-n', options.niceness, command);","        command = 'nice';","      }","","      var stdout = null;","      var stdoutClosed = false;","","      var stderr = null;","      var stderrClosed = false;","","      // Spawn process","      var ffmpegProc = spawn(command, args, options);","","      if (ffmpegProc.stderr && options.captureStderr) {","        ffmpegProc.stderr.setEncoding('utf8');","      }","","      ffmpegProc.on('error', function(err) {","        endCB(err);","      });","","      // Ensure we wait for captured streams to end before calling endCB","      var exitError = null;","      function handleExit(err) {","        if (err) {","          exitError = err;","        }","","        if (processExited &&","          (stdoutClosed || !options.captureStdout) &&","          (stderrClosed || !options.captureStderr)) {","          endCB(exitError, stdout, stderr);","        }","      }","","      // Handle process exit","      var processExited = false;","      ffmpegProc.on('exit', function(code, signal) {","        processExited = true;","","        if (signal) {","          handleExit(new Error('ffmpeg was killed with signal ' + signal));","        } else if (code) {","          handleExit(new Error('ffmpeg exited with code ' + code));","        } else {","          handleExit();","        }","      });","","      // Capture stdout if specified","      if (options.captureStdout) {","        stdout = '';","","        ffmpegProc.stdout.on('data', function(data) {","          stdout += data;","        });","","        ffmpegProc.stdout.on('close', function() {","          stdoutClosed = true;","          handleExit();","        });","      }","","      // Capture stderr if specified","      if (options.captureStderr) {","        stderr = '';","","        ffmpegProc.stderr.on('data', function(data) {","          stderr += data;","        });","","        ffmpegProc.stderr.on('close', function() {","          stderrClosed = true;","          handleExit();","        });","      }","","      // Call process callback","      processCB(ffmpegProc);","    });","  };","","","  /**","   * Build the argument list for an ffmpeg command","   *","   * @method FfmpegCommand#_getArguments","   * @return argument list","   * @private","   */","  proto._getArguments = function() {","    var complexFilters = this._complexFilters.get();","","    var fileOutput = this._outputs.some(function(output) {","      return output.isFile;","    });","","    return [].concat(","        // Inputs and input options","        this._inputs.reduce(function(args, input) {","          var source = (typeof input.source === 'string') ? input.source : 'pipe:0';","","          // For each input, add input options, then '-i <source>'","          return args.concat(","            input.options.get(),","            ['-i', source]","          );","        }, []),","","        // Global options","        this._global.get(),","","        // Overwrite if we have file outputs","        fileOutput ? ['-y'] : [],","","        // Complex filters","        complexFilters,","","        // Outputs, filters and output options","        this._outputs.reduce(function(args, output) {","          var audioFilters = output.audioFilters.get();","          var videoFilters = output.videoFilters.get().concat(output.sizeFilters.get());","          var outputArg;","","          if (!output.target) {","            outputArg = [];","          } else if (typeof output.target === 'string') {","            outputArg = [output.target];","          } else {","            outputArg = ['pipe:1'];","          }","","          return args.concat(","            output.audio.get(),","            audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [],","            output.video.get(),","            videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [],","            output.options.get(),","            outputArg","          );","        }, [])","      );","  };","","","  /**","   * Prepare execution of an ffmpeg command","   *","   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),","   * then builds the argument list for ffmpeg and pass them to 'callback'.","   *","   * @method FfmpegCommand#_prepare","   * @param {Function} callback callback with signature (err, args)","   * @param {Boolean} [readMetadata=false] read metadata before processing","   * @private","   */","  proto._prepare = function(callback, readMetadata) {","    var self = this;","","    async.waterfall([","      // Check codecs and formats","      function(cb) {","        self._checkCapabilities(cb);","      },","","      // Read metadata if required","      function(cb) {","        if (!readMetadata) {","          return cb();","        }","","        self.ffprobe(function(err, data) {","          if (!err) {","            self._ffprobeData = data;","          }","","          cb();","        });","      },","","      // Check for flvtool2/flvmeta if necessary","      function(cb) {","        var flvmeta = self._outputs.some(function(output) {","          // Remove flvmeta flag on non-file output","          if (output.flags.flvmeta && !output.isFile) {","            self.logger.warn('Updating flv metadata is only supported for files');","            output.flags.flvmeta = false;","          }","","          return output.flags.flvmeta;","        });","","        if (flvmeta) {","          self._getFlvtoolPath(function(err) {","            cb(err);","          });","        } else {","          cb();","        }","      },","","      // Build argument list","      function(cb) {","        var args;","        try {","          args = self._getArguments();","        } catch(e) {","          return cb(e);","        }","","        cb(null, args);","      }","    ], callback);","","    if (!readMetadata) {","      // Read metadata as soon as 'progress' listeners are added","","      if (this.listeners('progress').length > 0) {","        // Read metadata in parallel","        runFfprobe(this);","      } else {","        // Read metadata as soon as the first 'progress' listener is added","        this.once('newListener', function(event) {","          if (event === 'progress') {","            runFfprobe(this);","          }","        });","      }","    }","  };","","","  /**","   * Run ffmpeg command","   *","   * @method FfmpegCommand#run","   * @category Processing","   * @aliases exec,execute","   */","  proto.exec =","  proto.execute =","  proto.run = function() {","    var self = this;","","    // Check if at least one output is present","    var outputPresent = this._outputs.some(function(output) {","      return 'target' in output;","    });","","    if (!outputPresent) {","      throw new Error('No output specified');","    }","","    // Get output stream if any","    var outputStream = this._outputs.filter(function(output) {","      return typeof output.target !== 'string';","    })[0];","","    // Get input stream if any","    var inputStream = this._inputs.filter(function(input) {","      return typeof input.source !== 'string';","    })[0];","","    // Ensure we send 'end' or 'error' only once","    var ended = false;","    function emitEnd(err, stdout, stderr) {","      if (!ended) {","        ended = true;","","        if (err) {","          self.emit('error', err, stdout, stderr);","        } else {","          self.emit('end', stdout, stderr);","        }","      }","    }","","    self._prepare(function(err, args) {","      if (err) {","        return emitEnd(err);","      }","","      // Run ffmpeg","      var stdout = null;","      var stderr = '';","      self._spawnFfmpeg(","        args,","","        { niceness: self.options.niceness },","","        function processCB(ffmpegProc) {","          self.ffmpegProc = ffmpegProc;","          self.emit('start', 'ffmpeg ' + args.join(' '));","","          // Pipe input stream if any","          if (inputStream) {","            inputStream.source.on('error', function(err) {","              emitEnd(new Error('Input stream error: ' + err.message));","              ffmpegProc.kill();","            });","","            inputStream.source.resume();","            inputStream.source.pipe(ffmpegProc.stdin);","          }","","          // Setup timeout if requested","          var processTimer;","          if (self.options.timeout) {","            processTimer = setTimeout(function() {","              var msg = 'process ran into a timeout (' + self.options.timeout + 's)';","","              emitEnd(new Error(msg), stdout, stderr);","              ffmpegProc.kill();","            }, self.options.timeout * 1000);","          }","","          if (outputStream) {","            // Pipe ffmpeg stdout to output stream","            ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);","","            // Handle output stream events","            outputStream.target.on('close', function() {","              self.logger.debug('Output stream closed, scheduling kill for ffmpgeg process');","","              // Don't kill process yet, to give a chance to ffmpeg to","              // terminate successfully first  This is necessary because","              // under load, the process 'exit' event sometimes happens","              // after the output stream 'close' event.","              setTimeout(function() {","                emitEnd(new Error('Output stream closed'));","                ffmpegProc.kill();","              }, 20);","            });","","            outputStream.target.on('error', function(err) {","              self.logger.debug('Output stream error, killing ffmpgeg process');","              emitEnd(new Error('Output stream error: ' + err.message));","              ffmpegProc.kill();","            });","          } else {","            // Gather ffmpeg stdout","            stdout = '';","            ffmpegProc.stdout.on('data', function (data) {","              stdout += data;","            });","          }","","          // Process ffmpeg stderr data","          self._codecDataSent = false;","          ffmpegProc.stderr.on('data', function (data) {","            stderr += data;","","            if (!self._codecDataSent && self.listeners('codecData').length) {","              utils.extractCodecData(self, stderr);","            }","","            if (self.listeners('progress').length) {","              var duration = 0;","","              if (self._ffprobeData && self._ffprobeData.format && self._ffprobeData.format.duration) {","                duration = Number(self._ffprobeData.format.duration);","              }","","              utils.extractProgress(self, stderr, duration);","            }","          });","        },","","        function endCB(err) {","          delete self.ffmpegProc;","","          if (err) {","            if (err.message.match(/ffmpeg exited with code/)) {","              // Add ffmpeg error message","              err.message += ': ' + utils.extractError(stderr);","            }","","            emitEnd(err, stdout, stderr);","          } else {","            // Find out which outputs need flv metadata","            var flvmeta = self._outputs.filter(function(output) {","              return output.flags.flvmeta;","            });","","            if (flvmeta.length) {","              self._getFlvtoolPath(function(err, flvtool) {","                // No possible error here, _getFlvtoolPath was already called by _prepare","                async.each(","                  flvmeta,","                  function(output, cb) {","                    spawn(flvtool, ['-U', output.target])","                      .on('error', function(err) {","                        cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));","                      })","                      .on('exit', function(code, signal) {","                        if (code !== 0 || signal) {","                          cb(","                            new Error(flvtool + ' ' +","                              (signal ? 'received signal ' + signal","                                      : 'exited with code ' + code)) +","                              ' when running on ' + output.target","                          );","                        } else {","                          cb();","                        }","                      });","                  },","                  function(err) {","                    if (err) {","                      emitEnd(err);","                    } else {","                      emitEnd(null, stdout, stderr);","                    }","                  }","                );","              });","            } else {","              emitEnd(null, stdout, stderr);","            }","          }","        }","      );","    });","  };","","","  /**","   * Renice current and/or future ffmpeg processes","   *","   * Ignored on Windows platforms.","   *","   * @method FfmpegCommand#renice","   * @category Processing","   *","   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)","   * @return FfmpegCommand","   */","  proto.renice = function(niceness) {","    if (!utils.isWindows) {","      niceness = niceness || 0;","","      if (niceness < -20 || niceness > 20) {","        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');","      }","","      niceness = Math.min(20, Math.max(-20, niceness));","      this.options.niceness = niceness;","","      if (this.ffmpegProc) {","        var logger = this.logger;","        var pid = this.ffmpegProc.pid;","        var renice = spawn('renice', [niceness, '-p', pid]);","","        renice.on('error', function(err) {","          logger.warn('could not renice process ' + pid + ': ' + err.message);","        });","","        renice.on('exit', function(code, signal) {","          if (signal) {","            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);","          } else if (code) {","            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);","          } else {","            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');","          }","        });","      }","    }","","    return this;","  };","","","  /**","   * Kill current ffmpeg process, if any","   *","   * @method FfmpegCommand#kill","   * @category Processing","   *","   * @param {String} [signal=SIGKILL] signal name","   * @return FfmpegCommand","   */","  proto.kill = function(signal) {","    if (!this.ffmpegProc) {","      this.options.logger.warn('No running ffmpeg process, cannot send signal');","    } else {","      this.ffmpegProc.kill(signal || 'SIGKILL');","    }","","    return this;","  };","};",""];
"use strict";

_$jscoverage_done("lib/processor.js", 4);
var spawn = require("child_process").spawn;

_$jscoverage_done("lib/processor.js", 5);
var path = require("path");

_$jscoverage_done("lib/processor.js", 6);
var fs = require("fs");

_$jscoverage_done("lib/processor.js", 7);
var async = require("async");

_$jscoverage_done("lib/processor.js", 8);
var utils = require("./utils");

function runFfprobe(command) {
    _$jscoverage_done("lib/processor.js", 23);
    command.ffprobe(function(err, data) {
        _$jscoverage_done("lib/processor.js", 24);
        command._ffprobeData = data;
    });
}

_$jscoverage_done("lib/processor.js", 29);
module.exports = function(proto) {
    _$jscoverage_done("lib/processor.js", 100);
    proto._spawnFfmpeg = function(args, options, processCB, endCB) {
        _$jscoverage_done("lib/processor.js", 102);
        if (_$jscoverage_done("lib/processor.js", 102, typeof options === "function")) {
            _$jscoverage_done("lib/processor.js", 103);
            endCB = processCB;
            _$jscoverage_done("lib/processor.js", 104);
            processCB = options;
            _$jscoverage_done("lib/processor.js", 105);
            options = {};
        }
        _$jscoverage_done("lib/processor.js", 109);
        if (_$jscoverage_done("lib/processor.js", 109, typeof endCB === "undefined")) {
            _$jscoverage_done("lib/processor.js", 110);
            endCB = processCB;
            _$jscoverage_done("lib/processor.js", 111);
            processCB = function() {};
        }
        _$jscoverage_done("lib/processor.js", 115);
        this._getFfmpegPath(function(err, command) {
            _$jscoverage_done("lib/processor.js", 116);
            if (_$jscoverage_done("lib/processor.js", 116, err)) {
                _$jscoverage_done("lib/processor.js", 117);
                return endCB(err);
            } else {
                _$jscoverage_done("lib/processor.js", 118);
                if (_$jscoverage_done("lib/processor.js", 118, !command) || _$jscoverage_done("lib/processor.js", 118, command.length === 0)) {
                    _$jscoverage_done("lib/processor.js", 119);
                    return endCB(new Error("Cannot find ffmpeg"));
                }
            }
            _$jscoverage_done("lib/processor.js", 123);
            if (_$jscoverage_done("lib/processor.js", 123, options.niceness) && _$jscoverage_done("lib/processor.js", 123, options.niceness !== 0) && _$jscoverage_done("lib/processor.js", 123, !utils.isWindows)) {
                _$jscoverage_done("lib/processor.js", 124);
                args.unshift("-n", options.niceness, command);
                _$jscoverage_done("lib/processor.js", 125);
                command = "nice";
            }
            _$jscoverage_done("lib/processor.js", 128);
            var stdout = null;
            _$jscoverage_done("lib/processor.js", 129);
            var stdoutClosed = false;
            _$jscoverage_done("lib/processor.js", 131);
            var stderr = null;
            _$jscoverage_done("lib/processor.js", 132);
            var stderrClosed = false;
            _$jscoverage_done("lib/processor.js", 135);
            var ffmpegProc = spawn(command, args, options);
            _$jscoverage_done("lib/processor.js", 137);
            if (_$jscoverage_done("lib/processor.js", 137, ffmpegProc.stderr) && _$jscoverage_done("lib/processor.js", 137, options.captureStderr)) {
                _$jscoverage_done("lib/processor.js", 138);
                ffmpegProc.stderr.setEncoding("utf8");
            }
            _$jscoverage_done("lib/processor.js", 141);
            ffmpegProc.on("error", function(err) {
                _$jscoverage_done("lib/processor.js", 142);
                endCB(err);
            });
            _$jscoverage_done("lib/processor.js", 146);
            var exitError = null;
            function handleExit(err) {
                _$jscoverage_done("lib/processor.js", 148);
                if (_$jscoverage_done("lib/processor.js", 148, err)) {
                    _$jscoverage_done("lib/processor.js", 149);
                    exitError = err;
                }
                _$jscoverage_done("lib/processor.js", 152);
                if (_$jscoverage_done("lib/processor.js", 152, processExited) && (_$jscoverage_done("lib/processor.js", 152, stdoutClosed) || _$jscoverage_done("lib/processor.js", 152, !options.captureStdout)) && (_$jscoverage_done("lib/processor.js", 152, stderrClosed) || _$jscoverage_done("lib/processor.js", 152, !options.captureStderr))) {
                    _$jscoverage_done("lib/processor.js", 155);
                    endCB(exitError, stdout, stderr);
                }
            }
            _$jscoverage_done("lib/processor.js", 160);
            var processExited = false;
            _$jscoverage_done("lib/processor.js", 161);
            ffmpegProc.on("exit", function(code, signal) {
                _$jscoverage_done("lib/processor.js", 162);
                processExited = true;
                _$jscoverage_done("lib/processor.js", 164);
                if (_$jscoverage_done("lib/processor.js", 164, signal)) {
                    _$jscoverage_done("lib/processor.js", 165);
                    handleExit(new Error("ffmpeg was killed with signal " + signal));
                } else {
                    _$jscoverage_done("lib/processor.js", 166);
                    if (_$jscoverage_done("lib/processor.js", 166, code)) {
                        _$jscoverage_done("lib/processor.js", 167);
                        handleExit(new Error("ffmpeg exited with code " + code));
                    } else {
                        _$jscoverage_done("lib/processor.js", 169);
                        handleExit();
                    }
                }
            });
            _$jscoverage_done("lib/processor.js", 174);
            if (_$jscoverage_done("lib/processor.js", 174, options.captureStdout)) {
                _$jscoverage_done("lib/processor.js", 175);
                stdout = "";
                _$jscoverage_done("lib/processor.js", 177);
                ffmpegProc.stdout.on("data", function(data) {
                    _$jscoverage_done("lib/processor.js", 178);
                    stdout += data;
                });
                _$jscoverage_done("lib/processor.js", 181);
                ffmpegProc.stdout.on("close", function() {
                    _$jscoverage_done("lib/processor.js", 182);
                    stdoutClosed = true;
                    _$jscoverage_done("lib/processor.js", 183);
                    handleExit();
                });
            }
            _$jscoverage_done("lib/processor.js", 188);
            if (_$jscoverage_done("lib/processor.js", 188, options.captureStderr)) {
                _$jscoverage_done("lib/processor.js", 189);
                stderr = "";
                _$jscoverage_done("lib/processor.js", 191);
                ffmpegProc.stderr.on("data", function(data) {
                    _$jscoverage_done("lib/processor.js", 192);
                    stderr += data;
                });
                _$jscoverage_done("lib/processor.js", 195);
                ffmpegProc.stderr.on("close", function() {
                    _$jscoverage_done("lib/processor.js", 196);
                    stderrClosed = true;
                    _$jscoverage_done("lib/processor.js", 197);
                    handleExit();
                });
            }
            _$jscoverage_done("lib/processor.js", 202);
            processCB(ffmpegProc);
        });
    };
    _$jscoverage_done("lib/processor.js", 214);
    proto._getArguments = function() {
        _$jscoverage_done("lib/processor.js", 215);
        var complexFilters = this._complexFilters.get();
        _$jscoverage_done("lib/processor.js", 217);
        var fileOutput = this._outputs.some(function(output) {
            _$jscoverage_done("lib/processor.js", 218);
            return output.isFile;
        });
        _$jscoverage_done("lib/processor.js", 221);
        return [].concat(this._inputs.reduce(function(args, input) {
            _$jscoverage_done("lib/processor.js", 224);
            var source = typeof input.source === "string" ? input.source : "pipe:0";
            _$jscoverage_done("lib/processor.js", 227);
            return args.concat(input.options.get(), [ "-i", source ]);
        }, []), this._global.get(), fileOutput ? [ "-y" ] : [], complexFilters, this._outputs.reduce(function(args, output) {
            _$jscoverage_done("lib/processor.js", 244);
            var audioFilters = output.audioFilters.get();
            _$jscoverage_done("lib/processor.js", 245);
            var videoFilters = output.videoFilters.get().concat(output.sizeFilters.get());
            _$jscoverage_done("lib/processor.js", 246);
            var outputArg;
            _$jscoverage_done("lib/processor.js", 248);
            if (_$jscoverage_done("lib/processor.js", 248, !output.target)) {
                _$jscoverage_done("lib/processor.js", 249);
                outputArg = [];
            } else {
                _$jscoverage_done("lib/processor.js", 250);
                if (_$jscoverage_done("lib/processor.js", 250, typeof output.target === "string")) {
                    _$jscoverage_done("lib/processor.js", 251);
                    outputArg = [ output.target ];
                } else {
                    _$jscoverage_done("lib/processor.js", 253);
                    outputArg = [ "pipe:1" ];
                }
            }
            _$jscoverage_done("lib/processor.js", 256);
            return args.concat(output.audio.get(), audioFilters.length ? [ "-filter:a", audioFilters.join(",") ] : [], output.video.get(), videoFilters.length ? [ "-filter:v", videoFilters.join(",") ] : [], output.options.get(), outputArg);
        }, []));
    };
    _$jscoverage_done("lib/processor.js", 280);
    proto._prepare = function(callback, readMetadata) {
        _$jscoverage_done("lib/processor.js", 281);
        var self = this;
        _$jscoverage_done("lib/processor.js", 283);
        async.waterfall([ function(cb) {
            _$jscoverage_done("lib/processor.js", 286);
            self._checkCapabilities(cb);
        }, function(cb) {
            _$jscoverage_done("lib/processor.js", 291);
            if (_$jscoverage_done("lib/processor.js", 291, !readMetadata)) {
                _$jscoverage_done("lib/processor.js", 292);
                return cb();
            }
            _$jscoverage_done("lib/processor.js", 295);
            self.ffprobe(function(err, data) {
                _$jscoverage_done("lib/processor.js", 296);
                if (_$jscoverage_done("lib/processor.js", 296, !err)) {
                    _$jscoverage_done("lib/processor.js", 297);
                    self._ffprobeData = data;
                }
                _$jscoverage_done("lib/processor.js", 300);
                cb();
            });
        }, function(cb) {
            _$jscoverage_done("lib/processor.js", 306);
            var flvmeta = self._outputs.some(function(output) {
                _$jscoverage_done("lib/processor.js", 308);
                if (_$jscoverage_done("lib/processor.js", 308, output.flags.flvmeta) && _$jscoverage_done("lib/processor.js", 308, !output.isFile)) {
                    _$jscoverage_done("lib/processor.js", 309);
                    self.logger.warn("Updating flv metadata is only supported for files");
                    _$jscoverage_done("lib/processor.js", 310);
                    output.flags.flvmeta = false;
                }
                _$jscoverage_done("lib/processor.js", 313);
                return output.flags.flvmeta;
            });
            _$jscoverage_done("lib/processor.js", 316);
            if (_$jscoverage_done("lib/processor.js", 316, flvmeta)) {
                _$jscoverage_done("lib/processor.js", 317);
                self._getFlvtoolPath(function(err) {
                    _$jscoverage_done("lib/processor.js", 318);
                    cb(err);
                });
            } else {
                _$jscoverage_done("lib/processor.js", 321);
                cb();
            }
        }, function(cb) {
            _$jscoverage_done("lib/processor.js", 327);
            var args;
            _$jscoverage_done("lib/processor.js", 328);
            try {
                _$jscoverage_done("lib/processor.js", 329);
                args = self._getArguments();
            } catch (e) {
                _$jscoverage_done("lib/processor.js", 331);
                return cb(e);
            }
            _$jscoverage_done("lib/processor.js", 334);
            cb(null, args);
        } ], callback);
        _$jscoverage_done("lib/processor.js", 338);
        if (_$jscoverage_done("lib/processor.js", 338, !readMetadata)) {
            _$jscoverage_done("lib/processor.js", 341);
            if (_$jscoverage_done("lib/processor.js", 341, this.listeners("progress").length > 0)) {
                _$jscoverage_done("lib/processor.js", 343);
                runFfprobe(this);
            } else {
                _$jscoverage_done("lib/processor.js", 346);
                this.once("newListener", function(event) {
                    _$jscoverage_done("lib/processor.js", 347);
                    if (_$jscoverage_done("lib/processor.js", 347, event === "progress")) {
                        _$jscoverage_done("lib/processor.js", 348);
                        runFfprobe(this);
                    }
                });
            }
        }
    };
    _$jscoverage_done("lib/processor.js", 363);
    proto.exec = proto.execute = proto.run = function() {
        _$jscoverage_done("lib/processor.js", 366);
        var self = this;
        _$jscoverage_done("lib/processor.js", 369);
        var outputPresent = this._outputs.some(function(output) {
            _$jscoverage_done("lib/processor.js", 370);
            return "target" in output;
        });
        _$jscoverage_done("lib/processor.js", 373);
        if (_$jscoverage_done("lib/processor.js", 373, !outputPresent)) {
            _$jscoverage_done("lib/processor.js", 374);
            throw new Error("No output specified");
        }
        _$jscoverage_done("lib/processor.js", 378);
        var outputStream = this._outputs.filter(function(output) {
            _$jscoverage_done("lib/processor.js", 379);
            return typeof output.target !== "string";
        })[0];
        _$jscoverage_done("lib/processor.js", 383);
        var inputStream = this._inputs.filter(function(input) {
            _$jscoverage_done("lib/processor.js", 384);
            return typeof input.source !== "string";
        })[0];
        _$jscoverage_done("lib/processor.js", 388);
        var ended = false;
        function emitEnd(err, stdout, stderr) {
            _$jscoverage_done("lib/processor.js", 390);
            if (_$jscoverage_done("lib/processor.js", 390, !ended)) {
                _$jscoverage_done("lib/processor.js", 391);
                ended = true;
                _$jscoverage_done("lib/processor.js", 393);
                if (_$jscoverage_done("lib/processor.js", 393, err)) {
                    _$jscoverage_done("lib/processor.js", 394);
                    self.emit("error", err, stdout, stderr);
                } else {
                    _$jscoverage_done("lib/processor.js", 396);
                    self.emit("end", stdout, stderr);
                }
            }
        }
        _$jscoverage_done("lib/processor.js", 401);
        self._prepare(function(err, args) {
            _$jscoverage_done("lib/processor.js", 402);
            if (_$jscoverage_done("lib/processor.js", 402, err)) {
                _$jscoverage_done("lib/processor.js", 403);
                return emitEnd(err);
            }
            _$jscoverage_done("lib/processor.js", 407);
            var stdout = null;
            _$jscoverage_done("lib/processor.js", 408);
            var stderr = "";
            _$jscoverage_done("lib/processor.js", 409);
            self._spawnFfmpeg(args, {
                niceness: self.options.niceness
            }, function processCB(ffmpegProc) {
                _$jscoverage_done("lib/processor.js", 415);
                self.ffmpegProc = ffmpegProc;
                _$jscoverage_done("lib/processor.js", 416);
                self.emit("start", "ffmpeg " + args.join(" "));
                _$jscoverage_done("lib/processor.js", 419);
                if (_$jscoverage_done("lib/processor.js", 419, inputStream)) {
                    _$jscoverage_done("lib/processor.js", 420);
                    inputStream.source.on("error", function(err) {
                        _$jscoverage_done("lib/processor.js", 421);
                        emitEnd(new Error("Input stream error: " + err.message));
                        _$jscoverage_done("lib/processor.js", 422);
                        ffmpegProc.kill();
                    });
                    _$jscoverage_done("lib/processor.js", 425);
                    inputStream.source.resume();
                    _$jscoverage_done("lib/processor.js", 426);
                    inputStream.source.pipe(ffmpegProc.stdin);
                }
                _$jscoverage_done("lib/processor.js", 430);
                var processTimer;
                _$jscoverage_done("lib/processor.js", 431);
                if (_$jscoverage_done("lib/processor.js", 431, self.options.timeout)) {
                    _$jscoverage_done("lib/processor.js", 432);
                    processTimer = setTimeout(function() {
                        _$jscoverage_done("lib/processor.js", 433);
                        var msg = "process ran into a timeout (" + self.options.timeout + "s)";
                        _$jscoverage_done("lib/processor.js", 435);
                        emitEnd(new Error(msg), stdout, stderr);
                        _$jscoverage_done("lib/processor.js", 436);
                        ffmpegProc.kill();
                    }, self.options.timeout * 1e3);
                }
                _$jscoverage_done("lib/processor.js", 440);
                if (_$jscoverage_done("lib/processor.js", 440, outputStream)) {
                    _$jscoverage_done("lib/processor.js", 442);
                    ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);
                    _$jscoverage_done("lib/processor.js", 445);
                    outputStream.target.on("close", function() {
                        _$jscoverage_done("lib/processor.js", 446);
                        self.logger.debug("Output stream closed, scheduling kill for ffmpgeg process");
                        _$jscoverage_done("lib/processor.js", 452);
                        setTimeout(function() {
                            _$jscoverage_done("lib/processor.js", 453);
                            emitEnd(new Error("Output stream closed"));
                            _$jscoverage_done("lib/processor.js", 454);
                            ffmpegProc.kill();
                        }, 20);
                    });
                    _$jscoverage_done("lib/processor.js", 458);
                    outputStream.target.on("error", function(err) {
                        _$jscoverage_done("lib/processor.js", 459);
                        self.logger.debug("Output stream error, killing ffmpgeg process");
                        _$jscoverage_done("lib/processor.js", 460);
                        emitEnd(new Error("Output stream error: " + err.message));
                        _$jscoverage_done("lib/processor.js", 461);
                        ffmpegProc.kill();
                    });
                } else {
                    _$jscoverage_done("lib/processor.js", 465);
                    stdout = "";
                    _$jscoverage_done("lib/processor.js", 466);
                    ffmpegProc.stdout.on("data", function(data) {
                        _$jscoverage_done("lib/processor.js", 467);
                        stdout += data;
                    });
                }
                _$jscoverage_done("lib/processor.js", 472);
                self._codecDataSent = false;
                _$jscoverage_done("lib/processor.js", 473);
                ffmpegProc.stderr.on("data", function(data) {
                    _$jscoverage_done("lib/processor.js", 474);
                    stderr += data;
                    _$jscoverage_done("lib/processor.js", 476);
                    if (_$jscoverage_done("lib/processor.js", 476, !self._codecDataSent) && _$jscoverage_done("lib/processor.js", 476, self.listeners("codecData").length)) {
                        _$jscoverage_done("lib/processor.js", 477);
                        utils.extractCodecData(self, stderr);
                    }
                    _$jscoverage_done("lib/processor.js", 480);
                    if (_$jscoverage_done("lib/processor.js", 480, self.listeners("progress").length)) {
                        _$jscoverage_done("lib/processor.js", 481);
                        var duration = 0;
                        _$jscoverage_done("lib/processor.js", 483);
                        if (_$jscoverage_done("lib/processor.js", 483, self._ffprobeData) && _$jscoverage_done("lib/processor.js", 483, self._ffprobeData.format) && _$jscoverage_done("lib/processor.js", 483, self._ffprobeData.format.duration)) {
                            _$jscoverage_done("lib/processor.js", 484);
                            duration = Number(self._ffprobeData.format.duration);
                        }
                        _$jscoverage_done("lib/processor.js", 487);
                        utils.extractProgress(self, stderr, duration);
                    }
                });
            }, function endCB(err) {
                _$jscoverage_done("lib/processor.js", 493);
                delete self.ffmpegProc;
                _$jscoverage_done("lib/processor.js", 495);
                if (_$jscoverage_done("lib/processor.js", 495, err)) {
                    _$jscoverage_done("lib/processor.js", 496);
                    if (_$jscoverage_done("lib/processor.js", 496, err.message.match(/ffmpeg exited with code/))) {
                        _$jscoverage_done("lib/processor.js", 498);
                        err.message += ": " + utils.extractError(stderr);
                    }
                    _$jscoverage_done("lib/processor.js", 501);
                    emitEnd(err, stdout, stderr);
                } else {
                    _$jscoverage_done("lib/processor.js", 504);
                    var flvmeta = self._outputs.filter(function(output) {
                        _$jscoverage_done("lib/processor.js", 505);
                        return output.flags.flvmeta;
                    });
                    _$jscoverage_done("lib/processor.js", 508);
                    if (_$jscoverage_done("lib/processor.js", 508, flvmeta.length)) {
                        _$jscoverage_done("lib/processor.js", 509);
                        self._getFlvtoolPath(function(err, flvtool) {
                            _$jscoverage_done("lib/processor.js", 511);
                            async.each(flvmeta, function(output, cb) {
                                _$jscoverage_done("lib/processor.js", 514);
                                spawn(flvtool, [ "-U", output.target ]).on("error", function(err) {
                                    _$jscoverage_done("lib/processor.js", 516);
                                    cb(new Error("Error running " + flvtool + " on " + output.target + ": " + err.message));
                                }).on("exit", function(code, signal) {
                                    _$jscoverage_done("lib/processor.js", 519);
                                    if (_$jscoverage_done("lib/processor.js", 519, code !== 0) || _$jscoverage_done("lib/processor.js", 519, signal)) {
                                        _$jscoverage_done("lib/processor.js", 520);
                                        cb(new Error(flvtool + " " + (signal ? "received signal " + signal : "exited with code " + code)) + " when running on " + output.target);
                                    } else {
                                        _$jscoverage_done("lib/processor.js", 527);
                                        cb();
                                    }
                                });
                            }, function(err) {
                                _$jscoverage_done("lib/processor.js", 532);
                                if (_$jscoverage_done("lib/processor.js", 532, err)) {
                                    _$jscoverage_done("lib/processor.js", 533);
                                    emitEnd(err);
                                } else {
                                    _$jscoverage_done("lib/processor.js", 535);
                                    emitEnd(null, stdout, stderr);
                                }
                            });
                        });
                    } else {
                        _$jscoverage_done("lib/processor.js", 541);
                        emitEnd(null, stdout, stderr);
                    }
                }
            });
        });
    };
    _$jscoverage_done("lib/processor.js", 561);
    proto.renice = function(niceness) {
        _$jscoverage_done("lib/processor.js", 562);
        if (_$jscoverage_done("lib/processor.js", 562, !utils.isWindows)) {
            _$jscoverage_done("lib/processor.js", 563);
            niceness = niceness || 0;
            _$jscoverage_done("lib/processor.js", 565);
            if (_$jscoverage_done("lib/processor.js", 565, niceness < -20) || _$jscoverage_done("lib/processor.js", 565, niceness > 20)) {
                _$jscoverage_done("lib/processor.js", 566);
                this.logger.warn("Invalid niceness value: " + niceness + ", must be between -20 and 20");
            }
            _$jscoverage_done("lib/processor.js", 569);
            niceness = Math.min(20, Math.max(-20, niceness));
            _$jscoverage_done("lib/processor.js", 570);
            this.options.niceness = niceness;
            _$jscoverage_done("lib/processor.js", 572);
            if (_$jscoverage_done("lib/processor.js", 572, this.ffmpegProc)) {
                _$jscoverage_done("lib/processor.js", 573);
                var logger = this.logger;
                _$jscoverage_done("lib/processor.js", 574);
                var pid = this.ffmpegProc.pid;
                _$jscoverage_done("lib/processor.js", 575);
                var renice = spawn("renice", [ niceness, "-p", pid ]);
                _$jscoverage_done("lib/processor.js", 577);
                renice.on("error", function(err) {
                    _$jscoverage_done("lib/processor.js", 578);
                    logger.warn("could not renice process " + pid + ": " + err.message);
                });
                _$jscoverage_done("lib/processor.js", 581);
                renice.on("exit", function(code, signal) {
                    _$jscoverage_done("lib/processor.js", 582);
                    if (_$jscoverage_done("lib/processor.js", 582, signal)) {
                        _$jscoverage_done("lib/processor.js", 583);
                        logger.warn("could not renice process " + pid + ": renice was killed by signal " + signal);
                    } else {
                        _$jscoverage_done("lib/processor.js", 584);
                        if (_$jscoverage_done("lib/processor.js", 584, code)) {
                            _$jscoverage_done("lib/processor.js", 585);
                            logger.warn("could not renice process " + pid + ": renice exited with " + code);
                        } else {
                            _$jscoverage_done("lib/processor.js", 587);
                            logger.info("successfully reniced process " + pid + " to " + niceness + " niceness");
                        }
                    }
                });
            }
        }
        _$jscoverage_done("lib/processor.js", 593);
        return this;
    };
    _$jscoverage_done("lib/processor.js", 606);
    proto.kill = function(signal) {
        _$jscoverage_done("lib/processor.js", 607);
        if (_$jscoverage_done("lib/processor.js", 607, !this.ffmpegProc)) {
            _$jscoverage_done("lib/processor.js", 608);
            this.options.logger.warn("No running ffmpeg process, cannot send signal");
        } else {
            _$jscoverage_done("lib/processor.js", 610);
            this.ffmpegProc.kill(signal || "SIGKILL");
        }
        _$jscoverage_done("lib/processor.js", 613);
        return this;
    };
};